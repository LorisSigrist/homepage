# DTS-Buddy fixes Type-Declarations

There are some common pitfalls surrounding type-declarations that pretty much all TypeScript packages fall into, especially ones subpackages. [`dts-buddy`](https://www.npmjs.com/package/dts-buddy) is a tool that helps you avoid them.

## What is a type-declaration?

If you know what a type-declaration is, you can [skip this section](#the-pitfalls).

When you author a package with types, be it using TypeScript or JSdoc, you need to publish a type-declaration file along with your package for users to actually be able to use your types. The user's IDE will not bother to look at your source code to infer types, it will only look at the type-declaration file.

These files are the `.d.ts` files you see in most packages. They are usually generated by the TypeScript compiler. They contain just the types of your package, not the actual implementation.

## The Pitfalls

If you are just using the TypeScript compiler to generate your type-declarations, you will almost certainly run into most of these pitfalls.

### 1. Leaking internal types

The TypeScript compiler will generate type-declarations for all types that are exported from your package, including the ones that aren't meant to be used by consumers of your package. This increases the size of your package unnecessarily, and may, in the worst case, clutter up the user's IDE with types that are not meant to be used.

### 2. "Go to definition" doesn't work

When people are using your package, they might want to see the implementation of a type. This doesn't work for most TypeScript packages, as the IDE has no idea how to map the Type-Declarations to the actual source code. This is because the TypeScript compiler doesn't generate source maps by default.

## The Solution
`dts-buddy` solves all these things in a very clever way. Instead of associating the type-declarations with the JS build-output, relying on the module-resolution to match the two, it generates just one `.d.ts` file for the entire package. This is then referenced by the `types` field in your `package.json`.
The file contains module declarations for the public interface of the package and it's subpackages, using the `declare module` syntax. Here's an example output it generated for one of my (private, sorry) packages:

```ts
declare module '@sigrist.dev/jspdf-helpers/esr' {
    /**
    * Adds a QR-ESR Invoice footer to the given PDF.
    * 
    * Assumes the current page has A4 portrait format.
    * 
    * @see https://www.swiss-qr-invoice.org/validator/?lang=de for a validator
    */
    export function addQrEsrFooter(pdf: import("jspdf").jsPDF, data: ESRData) : import("jspdf").jsPDF;

    export type ESRData = {
        amount: number;
        reference: string;
        ...
    }
    ...
}

declare module '@sigrist.dev/jspdf-helpers/postage' {
  ...
}
```

Alongside this, it also generates a `.map.d.ts` file, which maps the public types onto the actual source code. This allows the IDE to "go to definition" and "peek definition" reliably.

## Should you use it?
If you are writing a package with subpackages, you should absolutely use it. It blows the alternatives out of the water. 

If you are writing a package without subpackages it's not super important that you use it, but there is still the benefit of smaller package-size and nicer "go to definition". If you have a lot of users it might be worth it.

If you are writing an application, you probably don't need it, as you don't publish your types anyway.
import{S as Ho,i as qo,s as Bo,k as o,q as l,a as c,l as p,m as r,r as i,h as a,c as u,n as k,M as es,p as os,b as t,G as e,H as Kt}from"../chunks/index.750437ab.js";const Uo=""+new URL("../assets/for-await-of-compat.3df2a5ba.webp",import.meta.url).href,so={width:1575,height:588},zo="#dfdedf",Fo=""+new URL("../assets/raw-stream.af5d3091.gif",import.meta.url).href,ao={width:1146,height:906},Vo="#e0e3df",Qo=""+new URL("../assets/text-stream.8cbdd213.gif",import.meta.url).href,no={width:818,height:568},Yo="#e2e4d7",$o=""+new URL("../assets/parse-result-value-stream.dc55853e.gif",import.meta.url).href,to={width:818,height:568},Ko="#f2f3ac",Xo=""+new URL("../assets/final-stream.7ab47112.gif",import.meta.url).href,eo={width:1178,height:568},Zo="#e2e5d8",sp=""+new URL("../assets/non-stream-load.67378d23.gif",import.meta.url).href,oo={width:1178,height:788},ap="#ecedcc",np=""+new URL("../assets/stream-load.a3f8ce89.gif",import.meta.url).href,po={width:1178,height:788},tp="#ededcd";function ep(lo){let S,ps,vn,na,ls,bn,ta,J,ro=`<code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> TodosSchema<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">Todo</span> <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./model"</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> display <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"my-framework"</span>

<span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"/todos"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//fetch</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//wait</span>
<span class="token keyword">const</span> todos <span class="token operator">=</span> TodosSchema<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>     <span class="token comment">//validate</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> todo <span class="token keyword">of</span> todos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">display</span><span class="token punctuation">(</span>todo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,ea,rs,gn,oa,d,Xt,pa,is,Tn,la,cs,En,ra,I,xs,_n,Sn,js,Pn,ia,us,In,ca,O,On,Ms,Wn,Ln,ua,ks,xn,ka,H,io=`<code class="language-ts"><span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body<span class="token punctuation">;</span>

<span class="token keyword">const</span> reader <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">getReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Get reader (boilerplate)</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> done <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//wait for value</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,ha,W,jn,Cs,Mn,Cn,fa,m,Zt,da,L,Dn,x,Ds,Rn,An,ma,j,Nn,Rs,Gn,Jn,wa,q,co='<code class="language-ts"><span class="token keyword">const</span> stream <span class="token operator">=</span> request<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TextDecoderStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>',ya,hs,Hn,va,w,se,ba,M,qn,As,Bn,Un,ga,C,zn,D,Ns,Fn,Vn,Ta,B,uo='<code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> @streamparser/json-whatwg</code>',Ea,f,Qn,Gs,Yn,$n,Js,Kn,Xn,Hs,Zn,st,_a,R,at,qs,nt,tt,Sa,U,ko=`<code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> JSONParser <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"@streamparser/json-whatwg"</span>
<span class="token operator">...</span>
<span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONParser</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> paths<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"$.*"</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span></code>`,Pa,fs,z,et,Bs,ot,pt,Ia,y,lt,Us,rt,it,zs,ct,ut,Oa,v,ae,Wa,h,kt,Fs,ht,ft,Vs,dt,mt,Qs,wt,yt,Ys,vt,bt,La,F,ho=`<code class="language-ts"><span class="token keyword">const</span> mapToValueStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransformStream</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token function">transform</span><span class="token punctuation">(</span>parsedElementInfo<span class="token punctuation">,</span> controller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		controller<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>parsedElementInfo<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,xa,ds,gt,ja,V,fo=`<code class="language-ts"><span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>valueStream<span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,Ma,b,ne,Ca,ms,Tt,Da,ws,Et,Ra,Q,mo=`<code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> display <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"my-framework"</span>
<span class="token operator">...</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> done <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token function">display</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Aa,g,te,Na,ys,_t,Ga,vs,St,Ja,Y,wo=`<code class="language-ts"><span class="token keyword">const</span> validateItemStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransformStream<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token punctuation">,</span> Item<span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> controller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
			controller<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>ItemSchema<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,Ha,bs,Pt,qa,$,yo=`<code class="language-ts"><span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>valueStream<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>validateTodoStream<span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,Ba,gs,It,Ua,K,vo=`<code class="language-js"><span class="token comment">// helpers.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> MapStream<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">O</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function-variable function">map</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">i</span><span class="token operator">:</span> <span class="token constant">I</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">O</span><span class="token punctuation">)</span><span class="token operator">:</span> TransformStream<span class="token operator">&lt;</span><span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">O</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransformStream</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
		<span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> controller</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
				controller<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,za,Ts,Ot,Fa,X,bo=`<code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> MapStream <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./helpers"</span>
<span class="token operator">...</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span><span class="token function">MapStream</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=></span> result<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span><span class="token function">MapStream</span><span class="token punctuation">(</span>TodoSchema<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span></code>`,Va,Es,Wt,Qa,A,Lt,$s,xt,jt,Ya,Z,go=`<code class="language-js"><span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> todo <span class="token keyword">of</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">display</span><span class="token punctuation">(</span>todo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,$a,T,ee,Ka,_s,Mt,Xa,ss,To=`<code class="language-ts"><span class="token comment">// helpers.ts</span>
<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token generic-function"><span class="token function">asIterable</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>stream<span class="token operator">:</span> ReadableStream<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> AsyncGenerator<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> reader <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">getReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">const</span> <span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> done <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">yield</span> value<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Za,N,Ct,Ks,Dt,Rt,sn,as,Eo=`<code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> MapStream<span class="token punctuation">,</span> asIterable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./helpers"</span>
<span class="token operator">...</span>
<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> todo <span class="token keyword">of</span> <span class="token function">asIterable</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">display</span><span class="token punctuation">(</span>todo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,an,Ss,At,nn,ns,_o=`<code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> JSONParser <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'@streamparser/json-whatwg'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> MapStream<span class="token punctuation">,</span> asIterable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./helpers'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> TodoSchema <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./TodoSchema'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/todos.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONParser</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	paths<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'$.*'</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> stream <span class="token operator">=</span> response<span class="token punctuation">.</span>body
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span><span class="token function">MapStream</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=></span> result<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">pipeThrough</span><span class="token punctuation">(</span><span class="token function">MapStream</span><span class="token punctuation">(</span>TodoSchema<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> todo <span class="token keyword">of</span> <span class="token function">asIterable</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">display</span><span class="token punctuation">(</span>todo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,tn,Ps,Nt,en,E,Xs,Gt,Jt,P,Ht,Zs,qt,Bt,sa,Ut,zt,Ft,ts,Vt,aa,Qt,Yt,on,Is,$t;return{c(){S=o("h1"),ps=o("a"),vn=l("The Better Way to load data"),na=c(),ls=o("p"),bn=l("When we are loading lists in out web-apps, we usually do the following. Our app makes a fetch request to a server, waits for all the data to arrive, maybe the app validates it, and then displays the items."),ta=c(),J=o("pre"),ea=c(),rs=o("p"),gn=l("But what if there are hundreds of items and the connection to the server is slow. If we wait for the entire response to arrive the user is going to see absolutely nothing for several seconds, and then see all the items at once. This feels sluggish. Unfortunately, for anyone taking the subway, this is a daily experience."),oa=c(),d=o("img"),pa=c(),is=o("p"),Tn=l("There might be a better way though. We don’t actually need to wait for all the data before we start displaying it. Once the data for the first item has made it over the network, we should be able display it. Having the items trickle in as the data arrives over the network would be a much nicer user experience."),la=c(),cs=o("p"),En=l("In this post we are going to implement this using streams."),ra=c(),I=o("blockquote"),xs=o("p"),_n=l("Quick note: In the Javascript world there are two different Stream APIs: Node Streams, and Web streams. Node Streams only work in Node, whereas Web Streams work both in Browsers and Node. Also, web-streams are sometimes called WHATWG-streams, after the standards organisation, It’s a mess."),Sn=c(),js=o("p"),Pn=l("We will be using web-streams."),ia=c(),us=o("p"),In=l("Fortunately this won’t be that hard."),ca=c(),O=o("p"),On=l("Our trusty fetch API is designed to make streaming easy. "),Ms=o("code"),Wn=l("response.body"),Ln=l(" is actually a stream that will give you access to the raw data coming in over the network, as it is coming in."),ua=c(),ks=o("p"),xn=l(`Let’s visualise that by logging each chunk of data as it arrives.
We can access a stream’s data by getting it’s reader and waiting for a value to arrive. Once a value arrives we log it and again wait for the next value, and then the next value, etc, until the stream is done.`),ka=c(),H=o("pre"),ha=c(),W=o("p"),jn=l("We now see see a bunch of "),Cs=o("code"),Mn=l("Uint8Arrays"),Cn=l(" in the console. This is the raw binary data arriving over the network."),fa=c(),m=o("img"),da=c(),L=o("p"),Dn=l(`But we want text, so let’s convert the raw data to text. We can modify a stream’s data using a TransformStream. A TransformStream takes in a stream, runs some logic on each chunk of data as it arrives, and writes the result to an outgoing stream.
In our case, we want a TransformStream that takes in a stream of raw binary data and outputs a stream of strings. This is such a common task that there actually is a built in one, the `),x=o("a"),Ds=o("code"),Rn=l("TextDecoderStream"),An=l(". Let’s use that. Don’t worry, we will be creating our own TransformStreams later on."),ma=c(),j=o("p"),Nn=l("Let’s hook the TextDecoder up to our stream using the "),Rs=o("code"),Gn=l("pipeThrough"),Jn=l(" method. This will return a new stream with the transform applied."),wa=c(),q=o("pre"),ya=c(),hs=o("p"),Hn=l("We now have a bunch of readable strings in the console."),va=c(),w=o("img"),ba=c(),M=o("p"),qn=l("But we really want a stream of objects that represent our items. We can’t just "),As=o("code"),Bn=l("JSON.parse"),Un=l(" each string-chunk, they don’t line up with the JSON structure; What we need is a streaming JSON parser."),ga=c(),C=o("p"),zn=l("Writing our own would be hard and undifferentiated work, so instead we’re going to use a library. There is a fantastic one called "),D=o("a"),Ns=o("code"),Fn=l("@streamparser/json-whatwg"),Vn=l(" which can create a TransformStream that takes in json-data and returns parsed objects."),Ta=c(),B=o("pre"),Ea=c(),f=o("p"),Qn=l("We can initialise the TransformStream using the "),Gs=o("code"),Yn=l("JSONParser"),$n=l(" constructor. We want each object in our todo-array to be emitted one after the other as they trickle in so let’s configure the parser for that. We can provide a pattern of which paths should be emitted as the "),Js=o("code"),Kn=l("paths"),Xn=l(" option; like a regex that runs on the paths. We want each child of the top-level array to be emitted. This can be expressed using the "),Hs=o("code"),Zn=l("$.*"),st=l(" pattern. The dollar-sign is always the top-level object, the array in our case, and the star is a wildcard that matches each direct child."),_a=c(),R=o("p"),at=l("Let’s add this parser to our stream-chain. This parser can also do the text-decoding internally so we don’t need the "),qs=o("code"),nt=l("TextDecoderStream"),tt=l(" anymore."),Sa=c(),U=o("pre"),Pa=c(),fs=o("blockquote"),z=o("p"),et=l("Optional Performance optimization: Add "),Bs=o("code"),ot=l("keepStack: false, stringBufferSize: undefined"),pt=l(" along with the paths option."),Ia=c(),y=o("p"),lt=l("In the console we now see a bunch of weird objects. The "),Us=o("code"),rt=l("value"),it=l(" property in each one contains our list items in their fully parsed glory. "),zs=o("code"),ct=l("JSONParser"),ut=l(" emits what it calls “ParsedElementInfo” objects, which contain the parsed values as well as some extra metadata. That’s what we’re seeing."),Oa=c(),v=o("img"),Wa=c(),h=o("p"),kt=l("Since we only care about the parsed values, let’s map over each element in the stream using, you guessed it, another Transform Stream. This time we’ll create our own. The constructor takes an object with some lifecycle methods. The "),Fs=o("code"),ht=l("start"),ft=l(" method runs when the stream starts, the "),Vs=o("code"),dt=l("flush"),mt=l(" method runs if the stream is about to be closed, and the "),Qs=o("code"),wt=l("transform"),yt=l(" method runs whenever a new chunk of data arrives. We will only be using "),Ys=o("code"),vt=l("transform"),bt=l(" . It takes two arguments the first one is the chunk of incoming data, in our case that is the ParsedElementInfo object from the JSONParser, and the second one is a stream-controller for the output stream. The stream-controller is how we write to or close the output stream. Here we enqueue the value property of each parsed element."),La=c(),F=o("pre"),xa=c(),ds=o("p"),gt=l("Let’s tack on our TransformStream and look at the console."),ja=c(),V=o("pre"),Ma=c(),b=o("img"),Ca=c(),ms=o("p"),Tt=l("That’s looking good already! We get list-items trickling in as the data is arriving over the network!"),Da=c(),ws=o("p"),Et=l("Let’s replace the log-statement with our rendering logic. I want to keep this post framework agnostic, so I won’t spend much time here. This is where you would hook into your UI framework."),Ra=c(),Q=o("pre"),Aa=c(),g=o("img"),Na=c(),ys=o("p"),_t=l("Just what we wanted!"),Ga=c(),vs=o("p"),St=l("The original code we had did one more thing that we are not yet doing. It validated the data. Let’s add that. We’re going to need another TransformStream. This one is very similar to the one we already made. We need to validate each element in the stream, and write it to the output if and only if it’s valid. You could throw an error if an item is invalid; I’m just going to fail silently."),Ja=c(),Y=o("pre"),Ha=c(),bs=o("p"),Pt=l("Let’s add it to the stream-chain. Still Works!"),qa=c(),$=o("pre"),Ba=c(),gs=o("p"),It=l("We’ve now implemented all the original functionality in a streaming manner, but there is an opportunity to refactor here. Our two TransformStreams are very similar. They each execute a mapping function over every element, and emit the result. Let’s DRY that up. We’re going to make a helper called MapStream that takes the mapping-function as an argument and returns a TransformStream that runs it for each chunk. If it throws, we ignore the element."),Ua=c(),K=o("pre"),za=c(),Ts=o("p"),Ot=l("We can now rewrite both our TransformStreams using the helper."),Fa=c(),X=o("pre"),Va=c(),Es=o("p"),Wt=l("Very expressive, isn’t it?"),Qa=c(),A=o("p"),Lt=l("With that, our implementation is done. But there is one more thing I would like to refactor; this while loop at the bottom. According to the spec, you’re supposed to be able to consume streams using a "),$s=o("code"),xt=l("for await of"),jt=l(" loop, but not everyone implements this."),Ya=c(),Z=o("pre"),$a=c(),T=o("img"),Ka=c(),_s=o("p"),Mt=l("Let’s write another helper that let’s us use the nicer syntax. If you’ve never used async-generators before, this will look unintelligible. That’s ok, this is entirely optional; Just stick with the while loop."),Xa=c(),ss=o("pre"),Za=c(),N=o("p"),Ct=l("We can now use "),Ks=o("code"),Dt=l("for await (const todo of asIterable(stream))"),Rt=l(" to asynchronously loop over the elements in the stream. I find this easier to read, since there is no control-flow."),sn=c(),as=o("pre"),an=c(),Ss=o("p"),At=l("The final code looks like this:"),nn=c(),ns=o("pre"),tn=c(),Ps=o("p"),Nt=l("A few observations to close out."),en=c(),E=o("ol"),Xs=o("li"),Gt=l("On slow connections, the Streaming version is both faster to show stuff to the user and also finishes earlier, since the parsing and validation happen in parallel with the fetching. On fast connections, the performance difference is negligible."),Jt=c(),P=o("li"),Ht=l("Once the "),Zs=o("code"),qt=l("MapStream"),Bt=l(" and "),sa=o("code"),Ut=l("asIterable"),zt=l(" helpers are defined, the streaming version of the code isn’t meaningfully longer. The effort for both versions is about the same."),Ft=c(),ts=o("li"),Vt=l("The bundle size for the streaming versions is slightly larger than the non-streaming version since we need to ship the JSONParser (+20kB). This isn’t always worth it. On sites with long session times it likely "),aa=o("em"),Qt=l("is"),Yt=l(" worth it, since the extra code is only sent once and every subsequent request can be sped up. In PWAs, where your code is already cached on the client, streaming is a no brainer."),on=c(),Is=o("p"),$t=l("There is a lot more you can do with streams, I really encourage you to play around with them. They’re a really powerful idea that applies to much more than just data-fetching. I hope you’ve learned something and have a good day."),this.h()},l(s){S=p(s,"H1",{id:!0});var n=r(S);ps=p(n,"A",{href:!0});var oe=r(ps);vn=i(oe,"The Better Way to load data"),oe.forEach(a),n.forEach(a),na=u(s),ls=p(s,"P",{});var pe=r(ls);bn=i(pe,"When we are loading lists in out web-apps, we usually do the following. Our app makes a fetch request to a server, waits for all the data to arrive, maybe the app validates it, and then displays the items."),pe.forEach(a),ta=u(s),J=p(s,"PRE",{class:!0});var So=r(J);So.forEach(a),ea=u(s),rs=p(s,"P",{});var le=r(rs);gn=i(le,"But what if there are hundreds of items and the connection to the server is slow. If we wait for the entire response to arrive the user is going to see absolutely nothing for several seconds, and then see all the items at once. This feels sluggish. Unfortunately, for anyone taking the subway, this is a daily experience."),le.forEach(a),oa=u(s),d=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),pa=u(s),is=p(s,"P",{});var re=r(is);Tn=i(re,"There might be a better way though. We don’t actually need to wait for all the data before we start displaying it. Once the data for the first item has made it over the network, we should be able display it. Having the items trickle in as the data arrives over the network would be a much nicer user experience."),re.forEach(a),la=u(s),cs=p(s,"P",{});var ie=r(cs);En=i(ie,"In this post we are going to implement this using streams."),ie.forEach(a),ra=u(s),I=p(s,"BLOCKQUOTE",{});var pn=r(I);xs=p(pn,"P",{});var ce=r(xs);_n=i(ce,"Quick note: In the Javascript world there are two different Stream APIs: Node Streams, and Web streams. Node Streams only work in Node, whereas Web Streams work both in Browsers and Node. Also, web-streams are sometimes called WHATWG-streams, after the standards organisation, It’s a mess."),ce.forEach(a),Sn=u(pn),js=p(pn,"P",{});var ue=r(js);Pn=i(ue,"We will be using web-streams."),ue.forEach(a),pn.forEach(a),ia=u(s),us=p(s,"P",{});var ke=r(us);In=i(ke,"Fortunately this won’t be that hard."),ke.forEach(a),ca=u(s),O=p(s,"P",{});var ln=r(O);On=i(ln,"Our trusty fetch API is designed to make streaming easy. "),Ms=p(ln,"CODE",{});var he=r(Ms);Wn=i(he,"response.body"),he.forEach(a),Ln=i(ln," is actually a stream that will give you access to the raw data coming in over the network, as it is coming in."),ln.forEach(a),ua=u(s),ks=p(s,"P",{});var fe=r(ks);xn=i(fe,`Let’s visualise that by logging each chunk of data as it arrives.
We can access a stream’s data by getting it’s reader and waiting for a value to arrive. Once a value arrives we log it and again wait for the next value, and then the next value, etc, until the stream is done.`),fe.forEach(a),ka=u(s),H=p(s,"PRE",{class:!0});var Po=r(H);Po.forEach(a),ha=u(s),W=p(s,"P",{});var rn=r(W);jn=i(rn,"We now see see a bunch of "),Cs=p(rn,"CODE",{});var de=r(Cs);Mn=i(de,"Uint8Arrays"),de.forEach(a),Cn=i(rn," in the console. This is the raw binary data arriving over the network."),rn.forEach(a),fa=u(s),m=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),da=u(s),L=p(s,"P",{});var cn=r(L);Dn=i(cn,`But we want text, so let’s convert the raw data to text. We can modify a stream’s data using a TransformStream. A TransformStream takes in a stream, runs some logic on each chunk of data as it arrives, and writes the result to an outgoing stream.
In our case, we want a TransformStream that takes in a stream of raw binary data and outputs a stream of strings. This is such a common task that there actually is a built in one, the `),x=p(cn,"A",{href:!0,rel:!0,target:!0});var me=r(x);Ds=p(me,"CODE",{});var we=r(Ds);Rn=i(we,"TextDecoderStream"),we.forEach(a),me.forEach(a),An=i(cn,". Let’s use that. Don’t worry, we will be creating our own TransformStreams later on."),cn.forEach(a),ma=u(s),j=p(s,"P",{});var un=r(j);Nn=i(un,"Let’s hook the TextDecoder up to our stream using the "),Rs=p(un,"CODE",{});var ye=r(Rs);Gn=i(ye,"pipeThrough"),ye.forEach(a),Jn=i(un," method. This will return a new stream with the transform applied."),un.forEach(a),wa=u(s),q=p(s,"PRE",{class:!0});var Io=r(q);Io.forEach(a),ya=u(s),hs=p(s,"P",{});var ve=r(hs);Hn=i(ve,"We now have a bunch of readable strings in the console."),ve.forEach(a),va=u(s),w=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),ba=u(s),M=p(s,"P",{});var kn=r(M);qn=i(kn,"But we really want a stream of objects that represent our items. We can’t just "),As=p(kn,"CODE",{});var be=r(As);Bn=i(be,"JSON.parse"),be.forEach(a),Un=i(kn," each string-chunk, they don’t line up with the JSON structure; What we need is a streaming JSON parser."),kn.forEach(a),ga=u(s),C=p(s,"P",{});var hn=r(C);zn=i(hn,"Writing our own would be hard and undifferentiated work, so instead we’re going to use a library. There is a fantastic one called "),D=p(hn,"A",{href:!0,rel:!0,target:!0});var ge=r(D);Ns=p(ge,"CODE",{});var Te=r(Ns);Fn=i(Te,"@streamparser/json-whatwg"),Te.forEach(a),ge.forEach(a),Vn=i(hn," which can create a TransformStream that takes in json-data and returns parsed objects."),hn.forEach(a),Ta=u(s),B=p(s,"PRE",{class:!0});var Oo=r(B);Oo.forEach(a),Ea=u(s),f=p(s,"P",{});var G=r(f);Qn=i(G,"We can initialise the TransformStream using the "),Gs=p(G,"CODE",{});var Ee=r(Gs);Yn=i(Ee,"JSONParser"),Ee.forEach(a),$n=i(G," constructor. We want each object in our todo-array to be emitted one after the other as they trickle in so let’s configure the parser for that. We can provide a pattern of which paths should be emitted as the "),Js=p(G,"CODE",{});var _e=r(Js);Kn=i(_e,"paths"),_e.forEach(a),Xn=i(G," option; like a regex that runs on the paths. We want each child of the top-level array to be emitted. This can be expressed using the "),Hs=p(G,"CODE",{});var Se=r(Hs);Zn=i(Se,"$.*"),Se.forEach(a),st=i(G," pattern. The dollar-sign is always the top-level object, the array in our case, and the star is a wildcard that matches each direct child."),G.forEach(a),_a=u(s),R=p(s,"P",{});var fn=r(R);at=i(fn,"Let’s add this parser to our stream-chain. This parser can also do the text-decoding internally so we don’t need the "),qs=p(fn,"CODE",{});var Pe=r(qs);nt=i(Pe,"TextDecoderStream"),Pe.forEach(a),tt=i(fn," anymore."),fn.forEach(a),Sa=u(s),U=p(s,"PRE",{class:!0});var Wo=r(U);Wo.forEach(a),Pa=u(s),fs=p(s,"BLOCKQUOTE",{});var Ie=r(fs);z=p(Ie,"P",{});var dn=r(z);et=i(dn,"Optional Performance optimization: Add "),Bs=p(dn,"CODE",{});var Oe=r(Bs);ot=i(Oe,"keepStack: false, stringBufferSize: undefined"),Oe.forEach(a),pt=i(dn," along with the paths option."),dn.forEach(a),Ie.forEach(a),Ia=u(s),y=p(s,"P",{});var Os=r(y);lt=i(Os,"In the console we now see a bunch of weird objects. The "),Us=p(Os,"CODE",{});var We=r(Us);rt=i(We,"value"),We.forEach(a),it=i(Os," property in each one contains our list items in their fully parsed glory. "),zs=p(Os,"CODE",{});var Le=r(zs);ct=i(Le,"JSONParser"),Le.forEach(a),ut=i(Os," emits what it calls “ParsedElementInfo” objects, which contain the parsed values as well as some extra metadata. That’s what we’re seeing."),Os.forEach(a),Oa=u(s),v=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),Wa=u(s),h=p(s,"P",{});var _=r(h);kt=i(_,"Since we only care about the parsed values, let’s map over each element in the stream using, you guessed it, another Transform Stream. This time we’ll create our own. The constructor takes an object with some lifecycle methods. The "),Fs=p(_,"CODE",{});var xe=r(Fs);ht=i(xe,"start"),xe.forEach(a),ft=i(_," method runs when the stream starts, the "),Vs=p(_,"CODE",{});var je=r(Vs);dt=i(je,"flush"),je.forEach(a),mt=i(_," method runs if the stream is about to be closed, and the "),Qs=p(_,"CODE",{});var Me=r(Qs);wt=i(Me,"transform"),Me.forEach(a),yt=i(_," method runs whenever a new chunk of data arrives. We will only be using "),Ys=p(_,"CODE",{});var Ce=r(Ys);vt=i(Ce,"transform"),Ce.forEach(a),bt=i(_," . It takes two arguments the first one is the chunk of incoming data, in our case that is the ParsedElementInfo object from the JSONParser, and the second one is a stream-controller for the output stream. The stream-controller is how we write to or close the output stream. Here we enqueue the value property of each parsed element."),_.forEach(a),La=u(s),F=p(s,"PRE",{class:!0});var Lo=r(F);Lo.forEach(a),xa=u(s),ds=p(s,"P",{});var De=r(ds);gt=i(De,"Let’s tack on our TransformStream and look at the console."),De.forEach(a),ja=u(s),V=p(s,"PRE",{class:!0});var xo=r(V);xo.forEach(a),Ma=u(s),b=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),Ca=u(s),ms=p(s,"P",{});var Re=r(ms);Tt=i(Re,"That’s looking good already! We get list-items trickling in as the data is arriving over the network!"),Re.forEach(a),Da=u(s),ws=p(s,"P",{});var Ae=r(ws);Et=i(Ae,"Let’s replace the log-statement with our rendering logic. I want to keep this post framework agnostic, so I won’t spend much time here. This is where you would hook into your UI framework."),Ae.forEach(a),Ra=u(s),Q=p(s,"PRE",{class:!0});var jo=r(Q);jo.forEach(a),Aa=u(s),g=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),Na=u(s),ys=p(s,"P",{});var Ne=r(ys);_t=i(Ne,"Just what we wanted!"),Ne.forEach(a),Ga=u(s),vs=p(s,"P",{});var Ge=r(vs);St=i(Ge,"The original code we had did one more thing that we are not yet doing. It validated the data. Let’s add that. We’re going to need another TransformStream. This one is very similar to the one we already made. We need to validate each element in the stream, and write it to the output if and only if it’s valid. You could throw an error if an item is invalid; I’m just going to fail silently."),Ge.forEach(a),Ja=u(s),Y=p(s,"PRE",{class:!0});var Mo=r(Y);Mo.forEach(a),Ha=u(s),bs=p(s,"P",{});var Je=r(bs);Pt=i(Je,"Let’s add it to the stream-chain. Still Works!"),Je.forEach(a),qa=u(s),$=p(s,"PRE",{class:!0});var Co=r($);Co.forEach(a),Ba=u(s),gs=p(s,"P",{});var He=r(gs);It=i(He,"We’ve now implemented all the original functionality in a streaming manner, but there is an opportunity to refactor here. Our two TransformStreams are very similar. They each execute a mapping function over every element, and emit the result. Let’s DRY that up. We’re going to make a helper called MapStream that takes the mapping-function as an argument and returns a TransformStream that runs it for each chunk. If it throws, we ignore the element."),He.forEach(a),Ua=u(s),K=p(s,"PRE",{class:!0});var Do=r(K);Do.forEach(a),za=u(s),Ts=p(s,"P",{});var qe=r(Ts);Ot=i(qe,"We can now rewrite both our TransformStreams using the helper."),qe.forEach(a),Fa=u(s),X=p(s,"PRE",{class:!0});var Ro=r(X);Ro.forEach(a),Va=u(s),Es=p(s,"P",{});var Be=r(Es);Wt=i(Be,"Very expressive, isn’t it?"),Be.forEach(a),Qa=u(s),A=p(s,"P",{});var mn=r(A);Lt=i(mn,"With that, our implementation is done. But there is one more thing I would like to refactor; this while loop at the bottom. According to the spec, you’re supposed to be able to consume streams using a "),$s=p(mn,"CODE",{});var Ue=r($s);xt=i(Ue,"for await of"),Ue.forEach(a),jt=i(mn," loop, but not everyone implements this."),mn.forEach(a),Ya=u(s),Z=p(s,"PRE",{class:!0});var Ao=r(Z);Ao.forEach(a),$a=u(s),T=p(s,"IMG",{src:!0,width:!0,height:!0,alt:!0}),Ka=u(s),_s=p(s,"P",{});var ze=r(_s);Mt=i(ze,"Let’s write another helper that let’s us use the nicer syntax. If you’ve never used async-generators before, this will look unintelligible. That’s ok, this is entirely optional; Just stick with the while loop."),ze.forEach(a),Xa=u(s),ss=p(s,"PRE",{class:!0});var No=r(ss);No.forEach(a),Za=u(s),N=p(s,"P",{});var wn=r(N);Ct=i(wn,"We can now use "),Ks=p(wn,"CODE",{});var Fe=r(Ks);Dt=i(Fe,"for await (const todo of asIterable(stream))"),Fe.forEach(a),Rt=i(wn," to asynchronously loop over the elements in the stream. I find this easier to read, since there is no control-flow."),wn.forEach(a),sn=u(s),as=p(s,"PRE",{class:!0});var Go=r(as);Go.forEach(a),an=u(s),Ss=p(s,"P",{});var Ve=r(Ss);At=i(Ve,"The final code looks like this:"),Ve.forEach(a),nn=u(s),ns=p(s,"PRE",{class:!0});var Jo=r(ns);Jo.forEach(a),tn=u(s),Ps=p(s,"P",{});var Qe=r(Ps);Nt=i(Qe,"A few observations to close out."),Qe.forEach(a),en=u(s),E=p(s,"OL",{});var Ws=r(E);Xs=p(Ws,"LI",{});var Ye=r(Xs);Gt=i(Ye,"On slow connections, the Streaming version is both faster to show stuff to the user and also finishes earlier, since the parsing and validation happen in parallel with the fetching. On fast connections, the performance difference is negligible."),Ye.forEach(a),Jt=u(Ws),P=p(Ws,"LI",{});var Ls=r(P);Ht=i(Ls,"Once the "),Zs=p(Ls,"CODE",{});var $e=r(Zs);qt=i($e,"MapStream"),$e.forEach(a),Bt=i(Ls," and "),sa=p(Ls,"CODE",{});var Ke=r(sa);Ut=i(Ke,"asIterable"),Ke.forEach(a),zt=i(Ls," helpers are defined, the streaming version of the code isn’t meaningfully longer. The effort for both versions is about the same."),Ls.forEach(a),Ft=u(Ws),ts=p(Ws,"LI",{});var yn=r(ts);Vt=i(yn,"The bundle size for the streaming versions is slightly larger than the non-streaming version since we need to ship the JSONParser (+20kB). This isn’t always worth it. On sites with long session times it likely "),aa=p(yn,"EM",{});var Xe=r(aa);Qt=i(Xe,"is"),Xe.forEach(a),Yt=i(yn," worth it, since the extra code is only sent once and every subsequent request can be sped up. In PWAs, where your code is already cached on the client, streaming is a no brainer."),yn.forEach(a),Ws.forEach(a),on=u(s),Is=p(s,"P",{});var Ze=r(Is);$t=i(Ze,"There is a lot more you can do with streams, I really encourage you to play around with them. They’re a really powerful idea that applies to much more than just data-fetching. I hope you’ve learned something and have a good day."),Ze.forEach(a),this.h()},h(){k(ps,"href","#the-better-way-to-load-data"),k(S,"id","the-better-way-to-load-data"),k(J,"class","language-ts"),es(d.src,Xt=sp)||k(d,"src",Xt),k(d,"width",oo.width),k(d,"height",oo.height),k(d,"alt","A list of items loading for a long time, and then being filled all at once"),os(d,"background-color",ap),k(H,"class","language-ts"),es(m.src,Zt=Fo)||k(m,"src",Zt),k(m,"width",ao.width),k(m,"height",ao.height),k(m,"alt","A bunch of Uint8Arrays being logged to the console"),os(m,"background-color",Vo),k(x,"href","https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream"),k(x,"rel","noopener noreferrer"),k(x,"target","_blank"),k(q,"class","language-ts"),es(w.src,se=Qo)||k(w,"src",se),k(w,"width",no.width),k(w,"height",no.height),k(w,"alt","A bunch of strings being logged to the console, with each being a chunk of a big JSON string"),os(w,"background-color",Yo),k(D,"href","https://www.npmjs.com/package/@streamparser/json-whatwg"),k(D,"rel","noopener noreferrer"),k(D,"target","_blank"),k(B,"class","language-bash"),k(U,"class","language-ts"),es(v.src,ae=$o)||k(v,"src",ae),k(v,"width",to.width),k(v,"height",to.height),k(v,"alt","A bunch of objects with the properties value,key,parent and stack being logged to the console"),os(v,"background-color",Ko),k(F,"class","language-ts"),k(V,"class","language-ts"),es(b.src,ne=Xo)||k(b,"src",ne),k(b,"width",eo.width),k(b,"height",eo.height),k(b,"alt","Each object in the list being logged out one after the other"),os(b,"background-color",Zo),k(Q,"class","language-ts"),es(g.src,te=np)||k(g,"src",te),k(g,"width",po.width),k(g,"height",po.height),k(g,"alt","The list being rendered one item at a time"),os(g,"background-color",tp),k(Y,"class","language-ts"),k($,"class","language-ts"),k(K,"class","language-js"),k(X,"class","language-js"),k(Z,"class","language-js"),es(T.src,ee=Uo)||k(T,"src",ee),k(T,"width",so.width),k(T,"height",so.height),k(T,"alt","Table showing that the 'for await of' syntax is only supported in Node, Deno and Firefox"),os(T,"background-color",zo),k(ss,"class","language-ts"),k(as,"class","language-js"),k(ns,"class","language-ts")},m(s,n){t(s,S,n),e(S,ps),e(ps,vn),t(s,na,n),t(s,ls,n),e(ls,bn),t(s,ta,n),t(s,J,n),J.innerHTML=ro,t(s,ea,n),t(s,rs,n),e(rs,gn),t(s,oa,n),t(s,d,n),t(s,pa,n),t(s,is,n),e(is,Tn),t(s,la,n),t(s,cs,n),e(cs,En),t(s,ra,n),t(s,I,n),e(I,xs),e(xs,_n),e(I,Sn),e(I,js),e(js,Pn),t(s,ia,n),t(s,us,n),e(us,In),t(s,ca,n),t(s,O,n),e(O,On),e(O,Ms),e(Ms,Wn),e(O,Ln),t(s,ua,n),t(s,ks,n),e(ks,xn),t(s,ka,n),t(s,H,n),H.innerHTML=io,t(s,ha,n),t(s,W,n),e(W,jn),e(W,Cs),e(Cs,Mn),e(W,Cn),t(s,fa,n),t(s,m,n),t(s,da,n),t(s,L,n),e(L,Dn),e(L,x),e(x,Ds),e(Ds,Rn),e(L,An),t(s,ma,n),t(s,j,n),e(j,Nn),e(j,Rs),e(Rs,Gn),e(j,Jn),t(s,wa,n),t(s,q,n),q.innerHTML=co,t(s,ya,n),t(s,hs,n),e(hs,Hn),t(s,va,n),t(s,w,n),t(s,ba,n),t(s,M,n),e(M,qn),e(M,As),e(As,Bn),e(M,Un),t(s,ga,n),t(s,C,n),e(C,zn),e(C,D),e(D,Ns),e(Ns,Fn),e(C,Vn),t(s,Ta,n),t(s,B,n),B.innerHTML=uo,t(s,Ea,n),t(s,f,n),e(f,Qn),e(f,Gs),e(Gs,Yn),e(f,$n),e(f,Js),e(Js,Kn),e(f,Xn),e(f,Hs),e(Hs,Zn),e(f,st),t(s,_a,n),t(s,R,n),e(R,at),e(R,qs),e(qs,nt),e(R,tt),t(s,Sa,n),t(s,U,n),U.innerHTML=ko,t(s,Pa,n),t(s,fs,n),e(fs,z),e(z,et),e(z,Bs),e(Bs,ot),e(z,pt),t(s,Ia,n),t(s,y,n),e(y,lt),e(y,Us),e(Us,rt),e(y,it),e(y,zs),e(zs,ct),e(y,ut),t(s,Oa,n),t(s,v,n),t(s,Wa,n),t(s,h,n),e(h,kt),e(h,Fs),e(Fs,ht),e(h,ft),e(h,Vs),e(Vs,dt),e(h,mt),e(h,Qs),e(Qs,wt),e(h,yt),e(h,Ys),e(Ys,vt),e(h,bt),t(s,La,n),t(s,F,n),F.innerHTML=ho,t(s,xa,n),t(s,ds,n),e(ds,gt),t(s,ja,n),t(s,V,n),V.innerHTML=fo,t(s,Ma,n),t(s,b,n),t(s,Ca,n),t(s,ms,n),e(ms,Tt),t(s,Da,n),t(s,ws,n),e(ws,Et),t(s,Ra,n),t(s,Q,n),Q.innerHTML=mo,t(s,Aa,n),t(s,g,n),t(s,Na,n),t(s,ys,n),e(ys,_t),t(s,Ga,n),t(s,vs,n),e(vs,St),t(s,Ja,n),t(s,Y,n),Y.innerHTML=wo,t(s,Ha,n),t(s,bs,n),e(bs,Pt),t(s,qa,n),t(s,$,n),$.innerHTML=yo,t(s,Ba,n),t(s,gs,n),e(gs,It),t(s,Ua,n),t(s,K,n),K.innerHTML=vo,t(s,za,n),t(s,Ts,n),e(Ts,Ot),t(s,Fa,n),t(s,X,n),X.innerHTML=bo,t(s,Va,n),t(s,Es,n),e(Es,Wt),t(s,Qa,n),t(s,A,n),e(A,Lt),e(A,$s),e($s,xt),e(A,jt),t(s,Ya,n),t(s,Z,n),Z.innerHTML=go,t(s,$a,n),t(s,T,n),t(s,Ka,n),t(s,_s,n),e(_s,Mt),t(s,Xa,n),t(s,ss,n),ss.innerHTML=To,t(s,Za,n),t(s,N,n),e(N,Ct),e(N,Ks),e(Ks,Dt),e(N,Rt),t(s,sn,n),t(s,as,n),as.innerHTML=Eo,t(s,an,n),t(s,Ss,n),e(Ss,At),t(s,nn,n),t(s,ns,n),ns.innerHTML=_o,t(s,tn,n),t(s,Ps,n),e(Ps,Nt),t(s,en,n),t(s,E,n),e(E,Xs),e(Xs,Gt),e(E,Jt),e(E,P),e(P,Ht),e(P,Zs),e(Zs,qt),e(P,Bt),e(P,sa),e(sa,Ut),e(P,zt),e(E,Ft),e(E,ts),e(ts,Vt),e(ts,aa),e(aa,Qt),e(ts,Yt),t(s,on,n),t(s,Is,n),e(Is,$t)},p:Kt,i:Kt,o:Kt,d(s){s&&a(S),s&&a(na),s&&a(ls),s&&a(ta),s&&a(J),s&&a(ea),s&&a(rs),s&&a(oa),s&&a(d),s&&a(pa),s&&a(is),s&&a(la),s&&a(cs),s&&a(ra),s&&a(I),s&&a(ia),s&&a(us),s&&a(ca),s&&a(O),s&&a(ua),s&&a(ks),s&&a(ka),s&&a(H),s&&a(ha),s&&a(W),s&&a(fa),s&&a(m),s&&a(da),s&&a(L),s&&a(ma),s&&a(j),s&&a(wa),s&&a(q),s&&a(ya),s&&a(hs),s&&a(va),s&&a(w),s&&a(ba),s&&a(M),s&&a(ga),s&&a(C),s&&a(Ta),s&&a(B),s&&a(Ea),s&&a(f),s&&a(_a),s&&a(R),s&&a(Sa),s&&a(U),s&&a(Pa),s&&a(fs),s&&a(Ia),s&&a(y),s&&a(Oa),s&&a(v),s&&a(Wa),s&&a(h),s&&a(La),s&&a(F),s&&a(xa),s&&a(ds),s&&a(ja),s&&a(V),s&&a(Ma),s&&a(b),s&&a(Ca),s&&a(ms),s&&a(Da),s&&a(ws),s&&a(Ra),s&&a(Q),s&&a(Aa),s&&a(g),s&&a(Na),s&&a(ys),s&&a(Ga),s&&a(vs),s&&a(Ja),s&&a(Y),s&&a(Ha),s&&a(bs),s&&a(qa),s&&a($),s&&a(Ba),s&&a(gs),s&&a(Ua),s&&a(K),s&&a(za),s&&a(Ts),s&&a(Fa),s&&a(X),s&&a(Va),s&&a(Es),s&&a(Qa),s&&a(A),s&&a(Ya),s&&a(Z),s&&a($a),s&&a(T),s&&a(Ka),s&&a(_s),s&&a(Xa),s&&a(ss),s&&a(Za),s&&a(N),s&&a(sn),s&&a(as),s&&a(an),s&&a(Ss),s&&a(nn),s&&a(ns),s&&a(tn),s&&a(Ps),s&&a(en),s&&a(E),s&&a(on),s&&a(Is)}}}class pp extends Ho{constructor(S){super(),qo(this,S,null,ep,Bo,{})}}export{pp as component};

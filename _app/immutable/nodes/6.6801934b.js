import{S as Ds,i as Ls,s as Ms,k as n,q as a,a as p,l,m as i,r as o,h as s,c as d,n as c,b as h,D as t,E as Wt}from"../chunks/index.4190156f.js";function Rs(){return{title:"Reliably Avoiding Theme flashes",description:"On sites with a theme-toggle, flashing the default theme before the user's choice is loaded is a common problem. Here's how to avoid it client-side only.",published:new Date("2023-07-10"),author:"Loris Sigrist"}}const Ps=Object.freeze(Object.defineProperty({__proto__:null,load:Rs},Symbol.toStringTag,{value:"Module"}));function Hs(Ss){let v,I,Ie,ue,P,K,C,Pe,Q,qe,Fe,fe,E,Be,T,Je,xe,me,D,q,We,ge,w,Ue,_,je,Ye,z,Ke,Qe,ye,u,ze,G,Ge,Ne,N,Ve,Xe,A,V,Ze,$e,X,et,tt,Z,st,at,we,F,ot,be,B,nt,ke,f,lt,$,it,rt,ee,ht,ct,te,pt,dt,se,ut,ft,ve,L,J,mt,Ee,g,gt,ae,yt,wt,oe,bt,kt,ne,vt,Et,Te,x,le,Tt,_e,M,Os=`<code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
		...
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
			document<span class="token punctuation">.</span>documentElement
			<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"theme"</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">"light"</span><span class="token punctuation">)</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code>`,Ae,m,_t,ie,At,St,re,Ot,Ct,he,Dt,Lt,ce,Mt,Rt,Se,W,R,Ht,pe,It,Pt,Oe,U,qt,Ce,H,j,Ft,De,S,Bt,de,Jt,xt;return{c(){v=n("h1"),I=n("a"),Ie=a("Reliably avoiding Theme Flashes"),ue=p(),P=n("blockquote"),K=n("p"),C=n("strong"),Pe=a("TLDR: Add a non-deferred "),Q=n("code"),qe=a("script"),Fe=a(" tag at the start of the document and react to the user’s theme preference there"),fe=p(),E=n("p"),Be=a("A common issue on sites with theme-toggles is a flash of the wrong theme when the page loads. In the hilariously titled post "),T=n("a"),Je=a("Flash of inAccurate coloR Theme (FART)"),xe=a(", Chris Coyier coined the term FART to describe this phenomenon. In this post, we will explore the cause of FARTs, and how to avoid them client-side only. Along the way we will be learning about how page-loading works in the browser."),me=p(),D=n("h2"),q=n("a"),We=a("Diagnosing the Problem"),ge=p(),w=n("p"),Ue=a("HTML is a streaming format. This is great, since we can display the content of a page before it has fully loaded. Even massive sites like the "),_=n("a"),je=a("HTML Specification"),Ye=a(" with it’s "),z=n("strong"),Ke=a("13MB (!)"),Qe=a(" of raw HTML can be displayed almost instantly. This is one of the most underrated features of the web."),ye=p(),u=n("p"),ze=a("But this poses a question when running Javascript. If the page has not fully loaded by the time our code runs, how does a selector like "),G=n("code"),Ge=a("document.getElementById"),Ne=a(` behave? Well, it only gets run on the part that has already been loaded.
This is dangerous when trying to hydrate a page, since the elements your code is trying to hydrate might not be there yet. To avoid this, pretty much all sites run their JS `),N=n("em"),Ve=a("after"),Xe=a(" the HTML has been fully recieved and parsed. We used to do this with "),A=n("a"),V=n("code"),Ze=a("DOMContentLoaded"),$e=a(" or by putting our scripts at the bottom of the page, but today we usually use "),X=n("code"),et=a("defered"),tt=a(", or "),Z=n("code"),st=a("type=module"),at=a(" on the script tag to achieve this."),we=p(),F=n("p"),ot=a("There is also the additional problem that non-deferred scripts are render-blocking, meaning that the browser will not render anything that comes after them until they have finished running. Loading your frontend framework like this would completely negate the benefits of SSR or prerendering, the behaviour would be identical to pure client-side-rendering."),be=p(),B=n("p"),nt=a("For these reasons pretty much all sites load their JS code in a deferred manner."),ke=p(),f=n("p"),lt=a("Unfortunately this causes FARTs. In order to decide which theme we should display, we need to check some sort local persistence. That might be "),$=n("code"),it=a("localStorage"),rt=a(", "),ee=n("code"),ht=a("IndexedDB"),ct=a(" or a plain old "),te=n("code"),pt=a("cookie"),dt=a(". Either way, JS needs to run. If our JS runs "),se=n("em"),ut=a("after"),ft=a(" the page has been fully parsed, as is the default nowadays, we get a flash of the default theme. You might get lucky and the browser will run your JS between finishing parsing and rendering, but you can’t rely on that."),ve=p(),L=n("h2"),J=n("a"),mt=a("The Solution"),Ee=p(),g=n("p"),gt=a("We need to somehow determine the desired theme before the page gets rendered. The way we do this is by returning the web-development stone age. The primitive "),ae=n("code"),yt=a("<script>"),wt=a(" tag with no "),oe=n("code"),bt=a("defer"),kt=a(" or "),ne=n("code"),vt=a('type="module"'),Et=a(" attributes will block the page from rendering until it has run. If we put our theme code in such a script we will not get a FART."),Te=p(),x=n("blockquote"),le=n("p"),Tt=a("Tip: Most projects have a skeleton HTML file somewhere, which is used as a template for all pages. Add the script there."),_e=p(),M=n("pre"),Ae=p(),m=n("p"),_t=a("Beware though. Since the HTML is not yet fully parsed when this script runs you only have guaranteed access to the elements that come before it, not after it. In the above example we could not safely add a class to the "),ie=n("code"),At=a("body"),St=a(", only to the "),re=n("code"),Ot=a("html"),Ct=a(" tag. Any elements that come before the script could potentially be displayed before it has run. You also need to account for that. The best place to put the script is usually either in the "),he=n("code"),Dt=a("head"),Lt=a(", or as the first thing in the "),ce=n("code"),Mt=a("body"),Rt=a("."),Se=p(),W=n("blockquote"),R=n("p"),Ht=a("Warning: If the theme logic is more complex, it’s tempting to put the JS in a separate file and load it via "),pe=n("code"),It=a("src"),Pt=a(". But that would require an additional HTTP request, during which the page cannot be rendered. Just inline it."),Oe=p(),U=n("p"),qt=a("There is another benefit to this. Elements with css transitions can often look awkward when switching themes, since they take longer than the rest of the page. This is especially noticeable during FARTs. By running the theme-switching code before the page has been rendered this problem is avoided, since the initial render will already be in the correct theme."),Ce=p(),H=n("h2"),j=n("a"),Ft=a("Addressing the concerns"),De=p(),S=n("p"),Bt=a("Some developers will avoid blocking scripts like the plague, since they used to be common sources of performance issues. However, in our case, the page cannot safely be rendered before the code has run, so this is an exception. Understanding "),de=n("em"),Jt=a("why"),xt=a(" something is considered bad practice is key to knowing when it’s okay to break the rules. Think of it like this: The theme-checking code needs to run anyway, so we might as well run it as early as possible. There is no performance loss."),this.h()},l(e){v=l(e,"H1",{id:!0});var r=i(v);I=l(r,"A",{href:!0});var Ut=i(I);Ie=o(Ut,"Reliably avoiding Theme Flashes"),Ut.forEach(s),r.forEach(s),ue=d(e),P=l(e,"BLOCKQUOTE",{});var jt=i(P);K=l(jt,"P",{});var Yt=i(K);C=l(Yt,"STRONG",{});var Le=i(C);Pe=o(Le,"TLDR: Add a non-deferred "),Q=l(Le,"CODE",{});var Kt=i(Q);qe=o(Kt,"script"),Kt.forEach(s),Fe=o(Le," tag at the start of the document and react to the user’s theme preference there"),Le.forEach(s),Yt.forEach(s),jt.forEach(s),fe=d(e),E=l(e,"P",{});var Me=i(E);Be=o(Me,"A common issue on sites with theme-toggles is a flash of the wrong theme when the page loads. In the hilariously titled post "),T=l(Me,"A",{href:!0,rel:!0,target:!0});var Qt=i(T);Je=o(Qt,"Flash of inAccurate coloR Theme (FART)"),Qt.forEach(s),xe=o(Me,", Chris Coyier coined the term FART to describe this phenomenon. In this post, we will explore the cause of FARTs, and how to avoid them client-side only. Along the way we will be learning about how page-loading works in the browser."),Me.forEach(s),me=d(e),D=l(e,"H2",{id:!0});var zt=i(D);q=l(zt,"A",{href:!0});var Gt=i(q);We=o(Gt,"Diagnosing the Problem"),Gt.forEach(s),zt.forEach(s),ge=d(e),w=l(e,"P",{});var Y=i(w);Ue=o(Y,"HTML is a streaming format. This is great, since we can display the content of a page before it has fully loaded. Even massive sites like the "),_=l(Y,"A",{href:!0,rel:!0,target:!0});var Nt=i(_);je=o(Nt,"HTML Specification"),Nt.forEach(s),Ye=o(Y," with it’s "),z=l(Y,"STRONG",{});var Vt=i(z);Ke=o(Vt,"13MB (!)"),Vt.forEach(s),Qe=o(Y," of raw HTML can be displayed almost instantly. This is one of the most underrated features of the web."),Y.forEach(s),ye=d(e),u=l(e,"P",{});var y=i(u);ze=o(y,"But this poses a question when running Javascript. If the page has not fully loaded by the time our code runs, how does a selector like "),G=l(y,"CODE",{});var Xt=i(G);Ge=o(Xt,"document.getElementById"),Xt.forEach(s),Ne=o(y,` behave? Well, it only gets run on the part that has already been loaded.
This is dangerous when trying to hydrate a page, since the elements your code is trying to hydrate might not be there yet. To avoid this, pretty much all sites run their JS `),N=l(y,"EM",{});var Zt=i(N);Ve=o(Zt,"after"),Zt.forEach(s),Xe=o(y," the HTML has been fully recieved and parsed. We used to do this with "),A=l(y,"A",{href:!0,rel:!0,target:!0});var $t=i(A);V=l($t,"CODE",{});var es=i(V);Ze=o(es,"DOMContentLoaded"),es.forEach(s),$t.forEach(s),$e=o(y," or by putting our scripts at the bottom of the page, but today we usually use "),X=l(y,"CODE",{});var ts=i(X);et=o(ts,"defered"),ts.forEach(s),tt=o(y,", or "),Z=l(y,"CODE",{});var ss=i(Z);st=o(ss,"type=module"),ss.forEach(s),at=o(y," on the script tag to achieve this."),y.forEach(s),we=d(e),F=l(e,"P",{});var as=i(F);ot=o(as,"There is also the additional problem that non-deferred scripts are render-blocking, meaning that the browser will not render anything that comes after them until they have finished running. Loading your frontend framework like this would completely negate the benefits of SSR or prerendering, the behaviour would be identical to pure client-side-rendering."),as.forEach(s),be=d(e),B=l(e,"P",{});var os=i(B);nt=o(os,"For these reasons pretty much all sites load their JS code in a deferred manner."),os.forEach(s),ke=d(e),f=l(e,"P",{});var b=i(f);lt=o(b,"Unfortunately this causes FARTs. In order to decide which theme we should display, we need to check some sort local persistence. That might be "),$=l(b,"CODE",{});var ns=i($);it=o(ns,"localStorage"),ns.forEach(s),rt=o(b,", "),ee=l(b,"CODE",{});var ls=i(ee);ht=o(ls,"IndexedDB"),ls.forEach(s),ct=o(b," or a plain old "),te=l(b,"CODE",{});var is=i(te);pt=o(is,"cookie"),is.forEach(s),dt=o(b,". Either way, JS needs to run. If our JS runs "),se=l(b,"EM",{});var rs=i(se);ut=o(rs,"after"),rs.forEach(s),ft=o(b," the page has been fully parsed, as is the default nowadays, we get a flash of the default theme. You might get lucky and the browser will run your JS between finishing parsing and rendering, but you can’t rely on that."),b.forEach(s),ve=d(e),L=l(e,"H2",{id:!0});var hs=i(L);J=l(hs,"A",{href:!0});var cs=i(J);mt=o(cs,"The Solution"),cs.forEach(s),hs.forEach(s),Ee=d(e),g=l(e,"P",{});var O=i(g);gt=o(O,"We need to somehow determine the desired theme before the page gets rendered. The way we do this is by returning the web-development stone age. The primitive "),ae=l(O,"CODE",{});var ps=i(ae);yt=o(ps,"<script>"),ps.forEach(s),wt=o(O," tag with no "),oe=l(O,"CODE",{});var ds=i(oe);bt=o(ds,"defer"),ds.forEach(s),kt=o(O," or "),ne=l(O,"CODE",{});var us=i(ne);vt=o(us,'type="module"'),us.forEach(s),Et=o(O," attributes will block the page from rendering until it has run. If we put our theme code in such a script we will not get a FART."),O.forEach(s),Te=d(e),x=l(e,"BLOCKQUOTE",{});var fs=i(x);le=l(fs,"P",{});var ms=i(le);Tt=o(ms,"Tip: Most projects have a skeleton HTML file somewhere, which is used as a template for all pages. Add the script there."),ms.forEach(s),fs.forEach(s),_e=d(e),M=l(e,"PRE",{class:!0});var Cs=i(M);Cs.forEach(s),Ae=d(e),m=l(e,"P",{});var k=i(m);_t=o(k,"Beware though. Since the HTML is not yet fully parsed when this script runs you only have guaranteed access to the elements that come before it, not after it. In the above example we could not safely add a class to the "),ie=l(k,"CODE",{});var gs=i(ie);At=o(gs,"body"),gs.forEach(s),St=o(k,", only to the "),re=l(k,"CODE",{});var ys=i(re);Ot=o(ys,"html"),ys.forEach(s),Ct=o(k," tag. Any elements that come before the script could potentially be displayed before it has run. You also need to account for that. The best place to put the script is usually either in the "),he=l(k,"CODE",{});var ws=i(he);Dt=o(ws,"head"),ws.forEach(s),Lt=o(k,", or as the first thing in the "),ce=l(k,"CODE",{});var bs=i(ce);Mt=o(bs,"body"),bs.forEach(s),Rt=o(k,"."),k.forEach(s),Se=d(e),W=l(e,"BLOCKQUOTE",{});var ks=i(W);R=l(ks,"P",{});var Re=i(R);Ht=o(Re,"Warning: If the theme logic is more complex, it’s tempting to put the JS in a separate file and load it via "),pe=l(Re,"CODE",{});var vs=i(pe);It=o(vs,"src"),vs.forEach(s),Pt=o(Re,". But that would require an additional HTTP request, during which the page cannot be rendered. Just inline it."),Re.forEach(s),ks.forEach(s),Oe=d(e),U=l(e,"P",{});var Es=i(U);qt=o(Es,"There is another benefit to this. Elements with css transitions can often look awkward when switching themes, since they take longer than the rest of the page. This is especially noticeable during FARTs. By running the theme-switching code before the page has been rendered this problem is avoided, since the initial render will already be in the correct theme."),Es.forEach(s),Ce=d(e),H=l(e,"H2",{id:!0});var Ts=i(H);j=l(Ts,"A",{href:!0});var _s=i(j);Ft=o(_s,"Addressing the concerns"),_s.forEach(s),Ts.forEach(s),De=d(e),S=l(e,"P",{});var He=i(S);Bt=o(He,"Some developers will avoid blocking scripts like the plague, since they used to be common sources of performance issues. However, in our case, the page cannot safely be rendered before the code has run, so this is an exception. Understanding "),de=l(He,"EM",{});var As=i(de);Jt=o(As,"why"),As.forEach(s),xt=o(He," something is considered bad practice is key to knowing when it’s okay to break the rules. Think of it like this: The theme-checking code needs to run anyway, so we might as well run it as early as possible. There is no performance loss."),He.forEach(s),this.h()},h(){c(I,"href","#reliably-avoiding-theme-flashes"),c(v,"id","reliably-avoiding-theme-flashes"),c(T,"href","https://css-tricks.com/flash-of-inaccurate-color-theme-fart/"),c(T,"rel","noopener noreferrer"),c(T,"target","_blank"),c(q,"href","#diagnosing-the-problem"),c(D,"id","diagnosing-the-problem"),c(_,"href","https://html.spec.whatwg.org/"),c(_,"rel","noopener noreferrer"),c(_,"target","_blank"),c(A,"href","https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event"),c(A,"rel","noopener noreferrer"),c(A,"target","_blank"),c(J,"href","#the-solution"),c(L,"id","the-solution"),c(M,"class","language-html"),c(j,"href","#addressing-the-concerns"),c(H,"id","addressing-the-concerns")},m(e,r){h(e,v,r),t(v,I),t(I,Ie),h(e,ue,r),h(e,P,r),t(P,K),t(K,C),t(C,Pe),t(C,Q),t(Q,qe),t(C,Fe),h(e,fe,r),h(e,E,r),t(E,Be),t(E,T),t(T,Je),t(E,xe),h(e,me,r),h(e,D,r),t(D,q),t(q,We),h(e,ge,r),h(e,w,r),t(w,Ue),t(w,_),t(_,je),t(w,Ye),t(w,z),t(z,Ke),t(w,Qe),h(e,ye,r),h(e,u,r),t(u,ze),t(u,G),t(G,Ge),t(u,Ne),t(u,N),t(N,Ve),t(u,Xe),t(u,A),t(A,V),t(V,Ze),t(u,$e),t(u,X),t(X,et),t(u,tt),t(u,Z),t(Z,st),t(u,at),h(e,we,r),h(e,F,r),t(F,ot),h(e,be,r),h(e,B,r),t(B,nt),h(e,ke,r),h(e,f,r),t(f,lt),t(f,$),t($,it),t(f,rt),t(f,ee),t(ee,ht),t(f,ct),t(f,te),t(te,pt),t(f,dt),t(f,se),t(se,ut),t(f,ft),h(e,ve,r),h(e,L,r),t(L,J),t(J,mt),h(e,Ee,r),h(e,g,r),t(g,gt),t(g,ae),t(ae,yt),t(g,wt),t(g,oe),t(oe,bt),t(g,kt),t(g,ne),t(ne,vt),t(g,Et),h(e,Te,r),h(e,x,r),t(x,le),t(le,Tt),h(e,_e,r),h(e,M,r),M.innerHTML=Os,h(e,Ae,r),h(e,m,r),t(m,_t),t(m,ie),t(ie,At),t(m,St),t(m,re),t(re,Ot),t(m,Ct),t(m,he),t(he,Dt),t(m,Lt),t(m,ce),t(ce,Mt),t(m,Rt),h(e,Se,r),h(e,W,r),t(W,R),t(R,Ht),t(R,pe),t(pe,It),t(R,Pt),h(e,Oe,r),h(e,U,r),t(U,qt),h(e,Ce,r),h(e,H,r),t(H,j),t(j,Ft),h(e,De,r),h(e,S,r),t(S,Bt),t(S,de),t(de,Jt),t(S,xt)},p:Wt,i:Wt,o:Wt,d(e){e&&s(v),e&&s(ue),e&&s(P),e&&s(fe),e&&s(E),e&&s(me),e&&s(D),e&&s(ge),e&&s(w),e&&s(ye),e&&s(u),e&&s(we),e&&s(F),e&&s(be),e&&s(B),e&&s(ke),e&&s(f),e&&s(ve),e&&s(L),e&&s(Ee),e&&s(g),e&&s(Te),e&&s(x),e&&s(_e),e&&s(M),e&&s(Ae),e&&s(m),e&&s(Se),e&&s(W),e&&s(Oe),e&&s(U),e&&s(Ce),e&&s(H),e&&s(De),e&&s(S)}}}class qs extends Ds{constructor(v){super(),Ls(this,v,null,Hs,Ms,{})}}export{qs as component,Ps as universal};

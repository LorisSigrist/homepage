import{S as Lt,i as Ut,s as Wt,k as p,q as a,a as c,l,m as r,r as n,h as s,c as u,n as d,b as i,G as t,H as Ks}from"../chunks/index.fae6157f.js";function Gt(St){let v,F,We,ye,I,z,Ge,Ne,he,T,Qe,q,Ye,me,x,J,ze,ve,m,Ke,K,Ve,Xe,V,Ze,$e,we,M,es,be,k,ss,X,ts,as,Z,ns,os,$,ps,ls,Ee,b,rs,ee,is,cs,ge,P,L,us,_e,f,se,ds,fs,te,ks,ys,ae,hs,ms,ne,vs,ws,oe,bs,Es,De,U,gs,je,S,Ot=`<code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'@sigrist.dev/framework/pdf'</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/**
    * Adds a QR-ESR Invoice footer to the given PDF.
    * Assumes the current page has A4 portrait format.
    *
    * @see https://www.swiss-qr-invoice.org/validator/?lang=de for a validator
    */</span>
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addQrEsrFooter</span><span class="token punctuation">(</span>pdf<span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"jspdf"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jsPDF<span class="token punctuation">,</span> data<span class="token operator">:</span> ESRData<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"jspdf"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jsPDF<span class="token punctuation">;</span>

    <span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ESRData</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        amount<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
        reference<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
        <span class="token operator">...</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'@sigrist.dev/framework/ui'</span> <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span></code>`,Ie,E,_s,pe,Ds,js,Te,O,W,Is,xe,G,Ts,Pe,C,Ct='<code class="language-sh"><span class="token function">pnpm</span> i <span class="token parameter variable">-D</span> dts-buddy</code>',Se,g,xs,le,Ps,Ss,Oe,A,At=`<code class="language-json"><span class="token punctuation">&#123;</span>
	<span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"node build.js"</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Ce,H,Ht=`<code class="language-js"><span class="token comment">// build.js</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createBundle <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'dts-buddy'</span><span class="token punctuation">;</span>

<span class="token comment">//Generate a bundle of all type-declarations</span>
<span class="token keyword">await</span> <span class="token function">createBundle</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token literal-property property">project</span><span class="token operator">:</span> <span class="token string">'tsconfig.json'</span><span class="token punctuation">,</span> <span class="token comment">//Your tsconfig.json</span>

	<span class="token comment">//Map subpackages to their entrypoints</span>
	<span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token string-property property">'@sigrist.dev/framework/pdf'</span><span class="token operator">:</span> <span class="token string">'src/pdf/index.js'</span><span class="token punctuation">,</span>
		<span class="token string-property property">'@sigrist.dev/framework/ui'</span><span class="token operator">:</span> <span class="token string">'src/ui/index.js'</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

	<span class="token literal-property property">include</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'src'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

	<span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token string">'types/index.d.ts'</span> <span class="token comment">//The resulting type-declaration file</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,Ae,y,Os,re,Cs,As,ie,Hs,Rs,ce,Bs,Fs,He,R,Rt=`<code class="language-json"><span class="token punctuation">&#123;</span>
	<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"types/index.d.ts"</span><span class="token punctuation">,</span> <span class="token comment">//here</span>
	<span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
		<span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"types/index.d.ts"</span><span class="token punctuation">,</span> <span class="token comment">//here</span>
			<span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./src/index.js"</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		<span class="token property">"./pdf"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"types/index.d.ts"</span><span class="token punctuation">,</span> <span class="token comment">//here</span>
			<span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./src/pdf/index.js"</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		<span class="token property">"./ui"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"types/index.d.ts"</span><span class="token punctuation">,</span> <span class="token comment">//here</span>
			<span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./src/ui/index.js"</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Re,_,qs,ue,Js,Ms,Be,B,N,Ls,Fe,w,de,Us,Ws,fe,Gs,Ns,qe,Q,Qs;return{c(){v=p("h1"),F=p("a"),We=a("DTS-Buddy fixes Type-Declarations"),ye=c(),I=p("p"),z=p("code"),Ge=a("dts-buddy"),Ne=a(" is one of those tools that’s hard to justify without encountering the problem they solve first. Here’s the story of how I ran into it."),he=c(),T=p("p"),Qe=a("If you don’t care why, you can "),q=p("a"),Ye=a("skip past the intro"),me=c(),x=p("h2"),J=p("a"),ze=a("A horror story about types in subpackages"),ve=c(),m=p("p"),Ke=a("I’ve been finding myself copying a lot of code between projects. To make this easier, I’ve been building a package where I keep all my commonly used code. Since it includes code from many domains, using subpackages seemed quite natural. "),K=p("code"),Ve=a("@sigrist.dev/framework/pdf"),Xe=a(" for all my PDF-related code, "),V=p("code"),Ze=a("@sigrist.dev/framework/ui"),$e=a(" for all my UI-related code, and so on."),we=c(),M=p("p"),es=a("To keep editing convenient, I opted to use JSDoc types, and generate type-declarations from them."),be=c(),k=p("p"),ss=a("While doing this, I quickly learned about the pitfalls of using subpackages. Using the TypeScript compiler means I was generating one "),X=p("code"),ts=a("d.ts"),as=a(" file per "),Z=p("code"),ns=a("js"),os=a(" file. This caused a problems when importing a subpackage. Whenever I started typing "),$=p("code"),ps=a("import {"),ls=a(" the IDE would show me a list of all the types present in the package, including ones that were not meant to be public. This was very irritating."),Ee=c(),b=p("p"),rs=a("Another issue I ran into is that "),ee=p("code"),is=a("go to definition"),cs=a(` didn’t work. I couldn’t jump to the implementation of a type, because the IDE didn’t know how to map the type-declaration to the actual source code.
As the declarations were always colocated with the JS file it wasn’t that bad, but still inconveniet. I often have to glance at the implementation to recall what was going on, since the package isn’t documented well.`),ge=c(),P=p("h2"),L=p("a"),us=a("Dts-Buddy; The savior"),_e=c(),f=p("p"),se=p("code"),ds=a("dts-buddy"),fs=a(" solves all these things in a very clever way. Instead of colocating each type-declaration with the JS file it belongs to, it generates just one "),te=p("code"),ks=a(".d.ts"),ys=a(" file for the entire package. This is then referenced by the "),ae=p("code"),hs=a("types"),ms=a(" field in your "),ne=p("code"),vs=a("package.json"),ws=a(`.
The file contains module declarations for the public interface of the package and it’s subpackages, using the `),oe=p("code"),bs=a("declare module"),Es=a(" syntax."),De=c(),U=p("p"),gs=a("Here’s an example output it generated for one of my (private, sorry) packages:"),je=c(),S=p("pre"),Ie=c(),E=p("p"),_s=a("Alongside this, it also generates a "),pe=p("code"),Ds=a(".map.d.ts"),js=a(" file, which maps the public types onto the actual source code. This allows the IDE to “go to definition” and “peek definition” reliably."),Te=c(),O=p("h2"),W=p("a"),Is=a("How to use it"),xe=c(),G=p("p"),Ts=a("First install it:"),Pe=c(),C=p("pre"),Se=c(),g=p("p"),xs=a("Then create a "),le=p("code"),Ps=a("build.js"),Ss=a(" file in your project, and use it as your build script:"),Oe=c(),A=p("pre"),Ce=c(),H=p("pre"),Ae=c(),y=p("p"),Os=a("The only thing left to do is to tell the module-resolution to actually use the generated file. So, in your "),re=p("code"),Cs=a("package.json"),As=a(", add a "),ie=p("code"),Hs=a("types"),Rs=a(" field, and also register it in each "),ce=p("code"),Bs=a("exports"),Fs=a(" field."),He=c(),R=p("pre"),Re=c(),_=p("p"),qs=a("That’s it! Now you can run "),ue=p("code"),Js=a("npm run build"),Ms=a(" and it’ll generate a single type-declaration file (+map) for your entire package."),Be=c(),B=p("h2"),N=p("a"),Ls=a("Should you use it?"),Fe=c(),w=p("p"),de=p("code"),Us=a("dts-buddy"),Ws=a(" is a tool that solves the subpackage-problem very very well. Outside of that, the regular TypeScript compiler is good enough. It’s going to be more familiar to most developers and is maintained more actively. But when you do need "),fe=p("code"),Gs=a("dts-buddy"),Ns=a(", it’s a lifesaver."),qe=c(),Q=p("p"),Qs=a("I for one have really enjoyed it and am very likely to choose it again."),this.h()},l(e){v=l(e,"H1",{id:!0});var o=r(v);F=l(o,"A",{href:!0});var Vs=r(F);We=n(Vs,"DTS-Buddy fixes Type-Declarations"),Vs.forEach(s),o.forEach(s),ye=u(e),I=l(e,"P",{});var Ys=r(I);z=l(Ys,"CODE",{});var Xs=r(z);Ge=n(Xs,"dts-buddy"),Xs.forEach(s),Ne=n(Ys," is one of those tools that’s hard to justify without encountering the problem they solve first. Here’s the story of how I ran into it."),Ys.forEach(s),he=u(e),T=l(e,"P",{});var zs=r(T);Qe=n(zs,"If you don’t care why, you can "),q=l(zs,"A",{href:!0});var Zs=r(q);Ye=n(Zs,"skip past the intro"),Zs.forEach(s),zs.forEach(s),me=u(e),x=l(e,"H2",{id:!0});var $s=r(x);J=l($s,"A",{href:!0});var et=r(J);ze=n(et,"A horror story about types in subpackages"),et.forEach(s),$s.forEach(s),ve=u(e),m=l(e,"P",{});var Y=r(m);Ke=n(Y,"I’ve been finding myself copying a lot of code between projects. To make this easier, I’ve been building a package where I keep all my commonly used code. Since it includes code from many domains, using subpackages seemed quite natural. "),K=l(Y,"CODE",{});var st=r(K);Ve=n(st,"@sigrist.dev/framework/pdf"),st.forEach(s),Xe=n(Y," for all my PDF-related code, "),V=l(Y,"CODE",{});var tt=r(V);Ze=n(tt,"@sigrist.dev/framework/ui"),tt.forEach(s),$e=n(Y," for all my UI-related code, and so on."),Y.forEach(s),we=u(e),M=l(e,"P",{});var at=r(M);es=n(at,"To keep editing convenient, I opted to use JSDoc types, and generate type-declarations from them."),at.forEach(s),be=u(e),k=l(e,"P",{});var D=r(k);ss=n(D,"While doing this, I quickly learned about the pitfalls of using subpackages. Using the TypeScript compiler means I was generating one "),X=l(D,"CODE",{});var nt=r(X);ts=n(nt,"d.ts"),nt.forEach(s),as=n(D," file per "),Z=l(D,"CODE",{});var ot=r(Z);ns=n(ot,"js"),ot.forEach(s),os=n(D," file. This caused a problems when importing a subpackage. Whenever I started typing "),$=l(D,"CODE",{});var pt=r($);ps=n(pt,"import {"),pt.forEach(s),ls=n(D," the IDE would show me a list of all the types present in the package, including ones that were not meant to be public. This was very irritating."),D.forEach(s),Ee=u(e),b=l(e,"P",{});var Je=r(b);rs=n(Je,"Another issue I ran into is that "),ee=l(Je,"CODE",{});var lt=r(ee);is=n(lt,"go to definition"),lt.forEach(s),cs=n(Je,` didn’t work. I couldn’t jump to the implementation of a type, because the IDE didn’t know how to map the type-declaration to the actual source code.
As the declarations were always colocated with the JS file it wasn’t that bad, but still inconveniet. I often have to glance at the implementation to recall what was going on, since the package isn’t documented well.`),Je.forEach(s),ge=u(e),P=l(e,"H2",{id:!0});var rt=r(P);L=l(rt,"A",{href:!0});var it=r(L);us=n(it,"Dts-Buddy; The savior"),it.forEach(s),rt.forEach(s),_e=u(e),f=l(e,"P",{});var h=r(f);se=l(h,"CODE",{});var ct=r(se);ds=n(ct,"dts-buddy"),ct.forEach(s),fs=n(h," solves all these things in a very clever way. Instead of colocating each type-declaration with the JS file it belongs to, it generates just one "),te=l(h,"CODE",{});var ut=r(te);ks=n(ut,".d.ts"),ut.forEach(s),ys=n(h," file for the entire package. This is then referenced by the "),ae=l(h,"CODE",{});var dt=r(ae);hs=n(dt,"types"),dt.forEach(s),ms=n(h," field in your "),ne=l(h,"CODE",{});var ft=r(ne);vs=n(ft,"package.json"),ft.forEach(s),ws=n(h,`.
The file contains module declarations for the public interface of the package and it’s subpackages, using the `),oe=l(h,"CODE",{});var kt=r(oe);bs=n(kt,"declare module"),kt.forEach(s),Es=n(h," syntax."),h.forEach(s),De=u(e),U=l(e,"P",{});var yt=r(U);gs=n(yt,"Here’s an example output it generated for one of my (private, sorry) packages:"),yt.forEach(s),je=u(e),S=l(e,"PRE",{class:!0});var Bt=r(S);Bt.forEach(s),Ie=u(e),E=l(e,"P",{});var Me=r(E);_s=n(Me,"Alongside this, it also generates a "),pe=l(Me,"CODE",{});var ht=r(pe);Ds=n(ht,".map.d.ts"),ht.forEach(s),js=n(Me," file, which maps the public types onto the actual source code. This allows the IDE to “go to definition” and “peek definition” reliably."),Me.forEach(s),Te=u(e),O=l(e,"H2",{id:!0});var mt=r(O);W=l(mt,"A",{href:!0});var vt=r(W);Is=n(vt,"How to use it"),vt.forEach(s),mt.forEach(s),xe=u(e),G=l(e,"P",{});var wt=r(G);Ts=n(wt,"First install it:"),wt.forEach(s),Pe=u(e),C=l(e,"PRE",{class:!0});var Ft=r(C);Ft.forEach(s),Se=u(e),g=l(e,"P",{});var Le=r(g);xs=n(Le,"Then create a "),le=l(Le,"CODE",{});var bt=r(le);Ps=n(bt,"build.js"),bt.forEach(s),Ss=n(Le," file in your project, and use it as your build script:"),Le.forEach(s),Oe=u(e),A=l(e,"PRE",{class:!0});var qt=r(A);qt.forEach(s),Ce=u(e),H=l(e,"PRE",{class:!0});var Jt=r(H);Jt.forEach(s),Ae=u(e),y=l(e,"P",{});var j=r(y);Os=n(j,"The only thing left to do is to tell the module-resolution to actually use the generated file. So, in your "),re=l(j,"CODE",{});var Et=r(re);Cs=n(Et,"package.json"),Et.forEach(s),As=n(j,", add a "),ie=l(j,"CODE",{});var gt=r(ie);Hs=n(gt,"types"),gt.forEach(s),Rs=n(j," field, and also register it in each "),ce=l(j,"CODE",{});var _t=r(ce);Bs=n(_t,"exports"),_t.forEach(s),Fs=n(j," field."),j.forEach(s),He=u(e),R=l(e,"PRE",{class:!0});var Mt=r(R);Mt.forEach(s),Re=u(e),_=l(e,"P",{});var Ue=r(_);qs=n(Ue,"That’s it! Now you can run "),ue=l(Ue,"CODE",{});var Dt=r(ue);Js=n(Dt,"npm run build"),Dt.forEach(s),Ms=n(Ue," and it’ll generate a single type-declaration file (+map) for your entire package."),Ue.forEach(s),Be=u(e),B=l(e,"H2",{id:!0});var jt=r(B);N=l(jt,"A",{href:!0});var It=r(N);Ls=n(It,"Should you use it?"),It.forEach(s),jt.forEach(s),Fe=u(e),w=l(e,"P",{});var ke=r(w);de=l(ke,"CODE",{});var Tt=r(de);Us=n(Tt,"dts-buddy"),Tt.forEach(s),Ws=n(ke," is a tool that solves the subpackage-problem very very well. Outside of that, the regular TypeScript compiler is good enough. It’s going to be more familiar to most developers and is maintained more actively. But when you do need "),fe=l(ke,"CODE",{});var xt=r(fe);Gs=n(xt,"dts-buddy"),xt.forEach(s),Ns=n(ke,", it’s a lifesaver."),ke.forEach(s),qe=u(e),Q=l(e,"P",{});var Pt=r(Q);Qs=n(Pt,"I for one have really enjoyed it and am very likely to choose it again."),Pt.forEach(s),this.h()},h(){d(F,"href","#dts-buddy-fixes-type-declarations"),d(v,"id","dts-buddy-fixes-type-declarations"),d(q,"href","#dts-buddy-the-savior"),d(J,"href","#a-horror-story-about-types-in-subpackages"),d(x,"id","a-horror-story-about-types-in-subpackages"),d(L,"href","#dts-buddy-the-savior"),d(P,"id","dts-buddy-the-savior"),d(S,"class","language-ts"),d(W,"href","#how-to-use-it"),d(O,"id","how-to-use-it"),d(C,"class","language-sh"),d(A,"class","language-json"),d(H,"class","language-js"),d(R,"class","language-json"),d(N,"href","#should-you-use-it"),d(B,"id","should-you-use-it")},m(e,o){i(e,v,o),t(v,F),t(F,We),i(e,ye,o),i(e,I,o),t(I,z),t(z,Ge),t(I,Ne),i(e,he,o),i(e,T,o),t(T,Qe),t(T,q),t(q,Ye),i(e,me,o),i(e,x,o),t(x,J),t(J,ze),i(e,ve,o),i(e,m,o),t(m,Ke),t(m,K),t(K,Ve),t(m,Xe),t(m,V),t(V,Ze),t(m,$e),i(e,we,o),i(e,M,o),t(M,es),i(e,be,o),i(e,k,o),t(k,ss),t(k,X),t(X,ts),t(k,as),t(k,Z),t(Z,ns),t(k,os),t(k,$),t($,ps),t(k,ls),i(e,Ee,o),i(e,b,o),t(b,rs),t(b,ee),t(ee,is),t(b,cs),i(e,ge,o),i(e,P,o),t(P,L),t(L,us),i(e,_e,o),i(e,f,o),t(f,se),t(se,ds),t(f,fs),t(f,te),t(te,ks),t(f,ys),t(f,ae),t(ae,hs),t(f,ms),t(f,ne),t(ne,vs),t(f,ws),t(f,oe),t(oe,bs),t(f,Es),i(e,De,o),i(e,U,o),t(U,gs),i(e,je,o),i(e,S,o),S.innerHTML=Ot,i(e,Ie,o),i(e,E,o),t(E,_s),t(E,pe),t(pe,Ds),t(E,js),i(e,Te,o),i(e,O,o),t(O,W),t(W,Is),i(e,xe,o),i(e,G,o),t(G,Ts),i(e,Pe,o),i(e,C,o),C.innerHTML=Ct,i(e,Se,o),i(e,g,o),t(g,xs),t(g,le),t(le,Ps),t(g,Ss),i(e,Oe,o),i(e,A,o),A.innerHTML=At,i(e,Ce,o),i(e,H,o),H.innerHTML=Ht,i(e,Ae,o),i(e,y,o),t(y,Os),t(y,re),t(re,Cs),t(y,As),t(y,ie),t(ie,Hs),t(y,Rs),t(y,ce),t(ce,Bs),t(y,Fs),i(e,He,o),i(e,R,o),R.innerHTML=Rt,i(e,Re,o),i(e,_,o),t(_,qs),t(_,ue),t(ue,Js),t(_,Ms),i(e,Be,o),i(e,B,o),t(B,N),t(N,Ls),i(e,Fe,o),i(e,w,o),t(w,de),t(de,Us),t(w,Ws),t(w,fe),t(fe,Gs),t(w,Ns),i(e,qe,o),i(e,Q,o),t(Q,Qs)},p:Ks,i:Ks,o:Ks,d(e){e&&s(v),e&&s(ye),e&&s(I),e&&s(he),e&&s(T),e&&s(me),e&&s(x),e&&s(ve),e&&s(m),e&&s(we),e&&s(M),e&&s(be),e&&s(k),e&&s(Ee),e&&s(b),e&&s(ge),e&&s(P),e&&s(_e),e&&s(f),e&&s(De),e&&s(U),e&&s(je),e&&s(S),e&&s(Ie),e&&s(E),e&&s(Te),e&&s(O),e&&s(xe),e&&s(G),e&&s(Pe),e&&s(C),e&&s(Se),e&&s(g),e&&s(Oe),e&&s(A),e&&s(Ce),e&&s(H),e&&s(Ae),e&&s(y),e&&s(He),e&&s(R),e&&s(Re),e&&s(_),e&&s(Be),e&&s(B),e&&s(Fe),e&&s(w),e&&s(qe),e&&s(Q)}}}class Qt extends Lt{constructor(v){super(),Ut(this,v,null,Gt,Wt,{})}}export{Qt as component};

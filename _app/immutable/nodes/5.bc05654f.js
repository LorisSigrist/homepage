import{S as Rt,i as zt,s as Ft,k as l,q as p,a as u,l as n,m as i,r,h as t,c,n as f,b as o,D as a,E as at}from"../chunks/index.4190156f.js";function Jt(Ct){let d,P,ve,Y,k,Ee,m,G,Te,_e,Z,E,x,ge,$,w,Se,j,De,Ie,ee,A,Pe,te,b,xe,Q,je,Ae,ae,T,H,He,se,C,Ce,oe,_,O,Oe,le,W,We,ne,g,R,Re,ie,z,ze,pe,S,F,Fe,re,h,M,Je,qe,K,Le,Be,N,Ge,Qe,U,Me,Ke,V,Ne,Ue,ue,D,Ot=`<code class="language-ts"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'@sigrist.dev/jspdf-helpers/esr'</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/**
    * Adds a QR-ESR Invoice footer to the given PDF.
    * 
    * Assumes the current page has A4 portrait format.
    * 
    * @see https://www.swiss-qr-invoice.org/validator/?lang=de for a validator
    */</span>
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addQrEsrFooter</span><span class="token punctuation">(</span>pdf<span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"jspdf"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jsPDF<span class="token punctuation">,</span> data<span class="token operator">:</span> ESRData<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"jspdf"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jsPDF<span class="token punctuation">;</span>

    <span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">ESRData</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        amount<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
        reference<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
        <span class="token operator">...</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'@sigrist.dev/jspdf-helpers/postage'</span> <span class="token punctuation">&#123;</span>
  <span class="token operator">...</span>
<span class="token punctuation">&#125;</span></code>`,ce,v,Ve,X,Xe,Ye,fe,I,J,Ze,he,q,$e,ye,L,et,de,B,tt;return{c(){d=l("h1"),P=l("a"),ve=p("DTS-Buddy fixes Type-Declarations"),Y=u(),k=l("p"),Ee=p("There are some common pitfalls surrounding type-declarations that pretty much all TypeScript packages fall into, especially ones subpackages. "),m=l("a"),G=l("code"),Te=p("dts-buddy"),_e=p(" is a tool that helps you avoid them."),Z=u(),E=l("h2"),x=l("a"),ge=p("What is a type-declaration?"),$=u(),w=l("p"),Se=p("If you know what a type-declaration is, you can "),j=l("a"),De=p("skip this section"),Ie=p("."),ee=u(),A=l("p"),Pe=p("When you author a package with types, be it using TypeScript or JSdoc, you need to publish a type-declaration file along with your package for users to actually be able to use your types. The user’s IDE will not bother to look at your source code to infer types, it will only look at the type-declaration file."),te=u(),b=l("p"),xe=p("These files are the "),Q=l("code"),je=p(".d.ts"),Ae=p(" files you see in most packages. They are usually generated by the TypeScript compiler. They contain just the types of your package, not the actual implementation."),ae=u(),T=l("h2"),H=l("a"),He=p("The Pitfalls"),se=u(),C=l("p"),Ce=p("If you are just using the TypeScript compiler to generate your type-declarations, you will almost certainly run into most of these pitfalls."),oe=u(),_=l("h3"),O=l("a"),Oe=p("1. Leaking internal types"),le=u(),W=l("p"),We=p("The TypeScript compiler will generate type-declarations for all types that are exported from your package, including the ones that aren’t meant to be used by consumers of your package. This increases the size of your package unnecessarily, and may, in the worst case, clutter up the user’s IDE with types that are not meant to be used."),ne=u(),g=l("h3"),R=l("a"),Re=p("2. “Go to definition” doesn’t work"),ie=u(),z=l("p"),ze=p("When people are using your package, they might want to see the implementation of a type. This doesn’t work for most TypeScript packages, as the IDE has no idea how to map the Type-Declarations to the actual source code. This is because the TypeScript compiler doesn’t generate source maps by default."),pe=u(),S=l("h2"),F=l("a"),Fe=p("The Solution"),re=u(),h=l("p"),M=l("code"),Je=p("dts-buddy"),qe=p(" solves all these things in a very clever way. Instead of associating the type-declarations with the JS build-output, relying on the module-resolution to match the two, it generates just one "),K=l("code"),Le=p(".d.ts"),Be=p(" file for the entire package. This is then referenced by the "),N=l("code"),Ge=p("types"),Qe=p(" field in your "),U=l("code"),Me=p("package.json"),Ke=p(`.
The file contains module declarations for the public interface of the package and it’s subpackages, using the `),V=l("code"),Ne=p("declare module"),Ue=p(" syntax. Here’s an example output it generated for one of my (private, sorry) packages:"),ue=u(),D=l("pre"),ce=u(),v=l("p"),Ve=p("Alongside this, it also generates a "),X=l("code"),Xe=p(".map.d.ts"),Ye=p(" file, which maps the public types onto the actual source code. This allows the IDE to “go to definition” and “peek definition” reliably."),fe=u(),I=l("h2"),J=l("a"),Ze=p("Should you use it?"),he=u(),q=l("p"),$e=p("If you are writing a package with subpackages, you should absolutely use it. It blows the alternatives out of the water."),ye=u(),L=l("p"),et=p("If you are writing a package without subpackages it’s not super important that you use it, but there is still the benefit of smaller package-size and nicer “go to definition”. If you have a lot of users it might be worth it."),de=u(),B=l("p"),tt=p("If you are writing an application, you probably don’t need it, as you don’t publish your types anyway."),this.h()},l(e){d=n(e,"H1",{id:!0});var s=i(d);P=n(s,"A",{href:!0});var st=i(P);ve=r(st,"DTS-Buddy fixes Type-Declarations"),st.forEach(t),s.forEach(t),Y=c(e),k=n(e,"P",{});var ke=i(k);Ee=r(ke,"There are some common pitfalls surrounding type-declarations that pretty much all TypeScript packages fall into, especially ones subpackages. "),m=n(ke,"A",{href:!0,rel:!0,target:!0});var ot=i(m);G=n(ot,"CODE",{});var lt=i(G);Te=r(lt,"dts-buddy"),lt.forEach(t),ot.forEach(t),_e=r(ke," is a tool that helps you avoid them."),ke.forEach(t),Z=c(e),E=n(e,"H2",{id:!0});var nt=i(E);x=n(nt,"A",{href:!0});var it=i(x);ge=r(it,"What is a type-declaration?"),it.forEach(t),nt.forEach(t),$=c(e),w=n(e,"P",{});var me=i(w);Se=r(me,"If you know what a type-declaration is, you can "),j=n(me,"A",{href:!0});var pt=i(j);De=r(pt,"skip this section"),pt.forEach(t),Ie=r(me,"."),me.forEach(t),ee=c(e),A=n(e,"P",{});var rt=i(A);Pe=r(rt,"When you author a package with types, be it using TypeScript or JSdoc, you need to publish a type-declaration file along with your package for users to actually be able to use your types. The user’s IDE will not bother to look at your source code to infer types, it will only look at the type-declaration file."),rt.forEach(t),te=c(e),b=n(e,"P",{});var we=i(b);xe=r(we,"These files are the "),Q=n(we,"CODE",{});var ut=i(Q);je=r(ut,".d.ts"),ut.forEach(t),Ae=r(we," files you see in most packages. They are usually generated by the TypeScript compiler. They contain just the types of your package, not the actual implementation."),we.forEach(t),ae=c(e),T=n(e,"H2",{id:!0});var ct=i(T);H=n(ct,"A",{href:!0});var ft=i(H);He=r(ft,"The Pitfalls"),ft.forEach(t),ct.forEach(t),se=c(e),C=n(e,"P",{});var ht=i(C);Ce=r(ht,"If you are just using the TypeScript compiler to generate your type-declarations, you will almost certainly run into most of these pitfalls."),ht.forEach(t),oe=c(e),_=n(e,"H3",{id:!0});var yt=i(_);O=n(yt,"A",{href:!0});var dt=i(O);Oe=r(dt,"1. Leaking internal types"),dt.forEach(t),yt.forEach(t),le=c(e),W=n(e,"P",{});var kt=i(W);We=r(kt,"The TypeScript compiler will generate type-declarations for all types that are exported from your package, including the ones that aren’t meant to be used by consumers of your package. This increases the size of your package unnecessarily, and may, in the worst case, clutter up the user’s IDE with types that are not meant to be used."),kt.forEach(t),ne=c(e),g=n(e,"H3",{id:!0});var mt=i(g);R=n(mt,"A",{href:!0});var wt=i(R);Re=r(wt,"2. “Go to definition” doesn’t work"),wt.forEach(t),mt.forEach(t),ie=c(e),z=n(e,"P",{});var bt=i(z);ze=r(bt,"When people are using your package, they might want to see the implementation of a type. This doesn’t work for most TypeScript packages, as the IDE has no idea how to map the Type-Declarations to the actual source code. This is because the TypeScript compiler doesn’t generate source maps by default."),bt.forEach(t),pe=c(e),S=n(e,"H2",{id:!0});var vt=i(S);F=n(vt,"A",{href:!0});var Et=i(F);Fe=r(Et,"The Solution"),Et.forEach(t),vt.forEach(t),re=c(e),h=n(e,"P",{});var y=i(h);M=n(y,"CODE",{});var Tt=i(M);Je=r(Tt,"dts-buddy"),Tt.forEach(t),qe=r(y," solves all these things in a very clever way. Instead of associating the type-declarations with the JS build-output, relying on the module-resolution to match the two, it generates just one "),K=n(y,"CODE",{});var _t=i(K);Le=r(_t,".d.ts"),_t.forEach(t),Be=r(y," file for the entire package. This is then referenced by the "),N=n(y,"CODE",{});var gt=i(N);Ge=r(gt,"types"),gt.forEach(t),Qe=r(y," field in your "),U=n(y,"CODE",{});var St=i(U);Me=r(St,"package.json"),St.forEach(t),Ke=r(y,`.
The file contains module declarations for the public interface of the package and it’s subpackages, using the `),V=n(y,"CODE",{});var Dt=i(V);Ne=r(Dt,"declare module"),Dt.forEach(t),Ue=r(y," syntax. Here’s an example output it generated for one of my (private, sorry) packages:"),y.forEach(t),ue=c(e),D=n(e,"PRE",{class:!0});var Wt=i(D);Wt.forEach(t),ce=c(e),v=n(e,"P",{});var be=i(v);Ve=r(be,"Alongside this, it also generates a "),X=n(be,"CODE",{});var It=i(X);Xe=r(It,".map.d.ts"),It.forEach(t),Ye=r(be," file, which maps the public types onto the actual source code. This allows the IDE to “go to definition” and “peek definition” reliably."),be.forEach(t),fe=c(e),I=n(e,"H2",{id:!0});var Pt=i(I);J=n(Pt,"A",{href:!0});var xt=i(J);Ze=r(xt,"Should you use it?"),xt.forEach(t),Pt.forEach(t),he=c(e),q=n(e,"P",{});var jt=i(q);$e=r(jt,"If you are writing a package with subpackages, you should absolutely use it. It blows the alternatives out of the water."),jt.forEach(t),ye=c(e),L=n(e,"P",{});var At=i(L);et=r(At,"If you are writing a package without subpackages it’s not super important that you use it, but there is still the benefit of smaller package-size and nicer “go to definition”. If you have a lot of users it might be worth it."),At.forEach(t),de=c(e),B=n(e,"P",{});var Ht=i(B);tt=r(Ht,"If you are writing an application, you probably don’t need it, as you don’t publish your types anyway."),Ht.forEach(t),this.h()},h(){f(P,"href","#dts-buddy-fixes-type-declarations"),f(d,"id","dts-buddy-fixes-type-declarations"),f(m,"href","https://www.npmjs.com/package/dts-buddy"),f(m,"rel","noopener noreferrer"),f(m,"target","_blank"),f(x,"href","#what-is-a-type-declaration"),f(E,"id","what-is-a-type-declaration"),f(j,"href","#the-pitfalls"),f(H,"href","#the-pitfalls"),f(T,"id","the-pitfalls"),f(O,"href","#1-leaking-internal-types"),f(_,"id","1-leaking-internal-types"),f(R,"href","#2-go-to-definition-doesnt-work"),f(g,"id","2-go-to-definition-doesnt-work"),f(F,"href","#the-solution"),f(S,"id","the-solution"),f(D,"class","language-ts"),f(J,"href","#should-you-use-it"),f(I,"id","should-you-use-it")},m(e,s){o(e,d,s),a(d,P),a(P,ve),o(e,Y,s),o(e,k,s),a(k,Ee),a(k,m),a(m,G),a(G,Te),a(k,_e),o(e,Z,s),o(e,E,s),a(E,x),a(x,ge),o(e,$,s),o(e,w,s),a(w,Se),a(w,j),a(j,De),a(w,Ie),o(e,ee,s),o(e,A,s),a(A,Pe),o(e,te,s),o(e,b,s),a(b,xe),a(b,Q),a(Q,je),a(b,Ae),o(e,ae,s),o(e,T,s),a(T,H),a(H,He),o(e,se,s),o(e,C,s),a(C,Ce),o(e,oe,s),o(e,_,s),a(_,O),a(O,Oe),o(e,le,s),o(e,W,s),a(W,We),o(e,ne,s),o(e,g,s),a(g,R),a(R,Re),o(e,ie,s),o(e,z,s),a(z,ze),o(e,pe,s),o(e,S,s),a(S,F),a(F,Fe),o(e,re,s),o(e,h,s),a(h,M),a(M,Je),a(h,qe),a(h,K),a(K,Le),a(h,Be),a(h,N),a(N,Ge),a(h,Qe),a(h,U),a(U,Me),a(h,Ke),a(h,V),a(V,Ne),a(h,Ue),o(e,ue,s),o(e,D,s),D.innerHTML=Ot,o(e,ce,s),o(e,v,s),a(v,Ve),a(v,X),a(X,Xe),a(v,Ye),o(e,fe,s),o(e,I,s),a(I,J),a(J,Ze),o(e,he,s),o(e,q,s),a(q,$e),o(e,ye,s),o(e,L,s),a(L,et),o(e,de,s),o(e,B,s),a(B,tt)},p:at,i:at,o:at,d(e){e&&t(d),e&&t(Y),e&&t(k),e&&t(Z),e&&t(E),e&&t($),e&&t(w),e&&t(ee),e&&t(A),e&&t(te),e&&t(b),e&&t(ae),e&&t(T),e&&t(se),e&&t(C),e&&t(oe),e&&t(_),e&&t(le),e&&t(W),e&&t(ne),e&&t(g),e&&t(ie),e&&t(z),e&&t(pe),e&&t(S),e&&t(re),e&&t(h),e&&t(ue),e&&t(D),e&&t(ce),e&&t(v),e&&t(fe),e&&t(I),e&&t(he),e&&t(q),e&&t(ye),e&&t(L),e&&t(de),e&&t(B)}}}class Lt extends Rt{constructor(d){super(),zt(this,d,null,Jt,Ft,{})}}export{Lt as component};
